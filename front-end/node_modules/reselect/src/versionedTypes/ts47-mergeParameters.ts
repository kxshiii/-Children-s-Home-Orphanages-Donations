// This entire implementation courtesy of Anders Hjelsberg:
// https://github.com/microsoft/TypeScript/pull/50831#issuecomment-1253830522

<<<<<<< HEAD
import { ReverseHead, ReverseTail } from '../types'

type UnknownFunction = (...args: any[]) => any

type LongestTuple<T> = T extends [infer U extends unknown[]]
  ? U
  : T extends [infer U, ...infer R extends unknown[][]]
  ? MostProperties<U, LongestTuple<R>>
  : never

type MostProperties<T, U> = keyof U extends keyof T ? T : U

type ElementAt<T, N extends keyof any> = N extends keyof T ? T[N] : unknown

type ElementsAt<T, N extends keyof any> = {
  [K in keyof T]: ElementAt<T[K], N>
}

type Intersect<T extends readonly unknown[]> = T extends []
  ? unknown
  : T extends [infer H, ...infer T]
  ? H & Intersect<T>
  : T[number]

type MergeTuples<T, L extends unknown[] = LongestTuple<T>> = {
  [K in keyof L]: Intersect<
    ElementsAt<T, K> extends readonly unknown[] ? ElementsAt<T, K> : never
  >
}

type ExtractParameters<T extends readonly UnknownFunction[]> = {
  [K in keyof T]: Parameters<T[K]>
}

export type MergeParameters<T extends readonly UnknownFunction[]> =
  '0' extends keyof T
    ? MergeTuples<MakeRestExplicit<ExtractParameters<T>>>
    : Parameters<T[number]>

type HasRest<S extends readonly unknown[]> = number extends S['length']
  ? true
  : false

type HasExplicit<S extends readonly unknown[]> = '0' extends keyof S
  ? true
  : false

type HasCombined<S extends readonly unknown[]> = true extends HasExplicit<S> &
  HasRest<S>
  ? true
  : false

type MakeRestExplicit<T extends readonly unknown[][]> =
  true extends HasCombined<T>
    ? [
        ...ReverseTail<T>,
        ReverseHead<T> extends readonly unknown[]
          ? ReverseHead<T>[number]
          : never
      ]
    : true extends HasRest<T>
    ? [...T]
    : T
=======
import type { AnyFunction } from '../types'

/**
 * Represents the longest array within an array of arrays.
 *
 * @template ArrayOfTuples An array of arrays.
 *
 * @internal
 */
type LongestTuple<ArrayOfTuples extends readonly unknown[][]> =
  ArrayOfTuples extends [infer FirstArray extends unknown[]]
    ? FirstArray
    : ArrayOfTuples extends [
        infer FirstArray,
        ...infer RestArrays extends unknown[][]
      ]
    ? LongerOfTwo<FirstArray, LongestTuple<RestArrays>>
    : never

/**
 * Determines the longer of two array types.
 *
 * @template ArrayOne First array type.
 * @template ArrayTwo Second array type.
 *
 * @internal
 */
type LongerOfTwo<ArrayOne, ArrayTwo> = keyof ArrayTwo extends keyof ArrayOne
  ? ArrayOne
  : ArrayTwo

/**
 * Extracts the element at a specific index in an array.
 *
 * @template ArrayType The array type.
 * @template Index The index type.
 *
 * @internal
 */
type ElementAt<
  ArrayType extends unknown[],
  Index extends PropertyKey
> = Index extends keyof ArrayType ? ArrayType[Index] : unknown

/**
 * Maps each array in an array of arrays to its element at a given index.
 *
 * @template ArrayOfTuples An array of arrays.
 * @template Index The index to extract from each array.
 *
 * @internal
 */
type ElementsAtGivenIndex<
  ArrayOfTuples extends readonly unknown[][],
  Index extends PropertyKey
> = {
  [ArrayIndex in keyof ArrayOfTuples]: ElementAt<
    ArrayOfTuples[ArrayIndex],
    Index
  >
}

/**
 * Computes the intersection of all types in a tuple.
 *
 * @template Tuple A tuple of types.
 *
 * @internal
 */
type Intersect<Tuple extends readonly unknown[]> = Tuple extends []
  ? unknown
  : Tuple extends [infer Head, ...infer Tail]
  ? Head & Intersect<Tail>
  : Tuple[number]

/**
 * Merges a tuple of arrays into a single tuple, intersecting types at each index.
 *
 * @template ArrayOfTuples An array of tuples.
 * @template LongestArray The longest array in ArrayOfTuples.
 *
 * @internal
 */
type MergeTuples<
  ArrayOfTuples extends readonly unknown[][],
  LongestArray extends unknown[] = LongestTuple<ArrayOfTuples>
> = {
  [Index in keyof LongestArray]: Intersect<
    ElementsAtGivenIndex<ArrayOfTuples, Index>
  >
}

/**
 * Extracts the parameter types from a tuple of functions.
 *
 * @template FunctionsArray An array of function types.
 *
 * @internal
 */
type ExtractParameters<FunctionsArray extends readonly AnyFunction[]> = {
  [Index in keyof FunctionsArray]: Parameters<FunctionsArray[Index]>
}

/**
 * Merges the parameters of a tuple of functions into a single tuple.
 *
 * @template FunctionsArray An array of function types.
 *
 * @internal
 */
export type MergeParameters<FunctionsArray extends readonly AnyFunction[]> =
  '0' extends keyof FunctionsArray
    ? MergeTuples<ExtractParameters<FunctionsArray>>
    : Parameters<FunctionsArray[number]>
>>>>>>> main
